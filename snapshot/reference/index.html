<!DOCTYPE html>
<html lang="">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="author" content="Kai Tödter">
<title>JSON:API for Spring HATEOAS</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>JSON:API for Spring HATEOAS</h1>
<div class="details">
<span id="author" class="author">Kai Tödter</span><br>
<span id="revnumber">version 3.0.1-SNAPSHOT,</span>
<span id="revdate">2025-12-24</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#project-metadata">Project Metadata</a></li>
<li><a href="#introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#fundamentals">1.1. Fundamentals</a></li>
<li><a href="#jsonapi">1.2. JSON:API</a></li>
</ul>
</li>
<li><a href="#setup">2. Setup</a>
<ul class="sectlevel2">
<li><a href="#version-requirements">2.1. Version Requirements</a></li>
</ul>
</li>
<li><a href="#migration">3. Migration Guide</a>
<ul class="sectlevel2">
<li><a href="#migration-3-0-0">3.1. Migrating to Version 3.0.0</a>
<ul class="sectlevel3">
<li><a href="#breaking-changes">3.1.1. Breaking Changes</a>
<ul class="sectlevel4">
<li><a href="#removed-deprecated-apis">Removed Deprecated APIs</a></li>
<li><a href="#spring-boot-4-and-spring-framework-7">Spring Boot 4 and Spring Framework 7</a></li>
<li><a href="#jackson-3-migration">Jackson 3 Migration</a>
<ul class="sectlevel5">
<li><a href="#package-changes">Package Changes</a></li>
<li><a href="#api-changes">API Changes</a></li>
<li><a href="#jsonapi-version-rendering">JSON:API Version Rendering</a></li>
<li><a href="#mapper-customization">Mapper Customization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#custom-serializers-and-deserializers">3.1.2. Custom Serializers and Deserializers</a>
<ul class="sectlevel4">
<li><a href="#resttemplate-restclient">RestTemplate → RestClient</a></li>
</ul>
</li>
<li><a href="#new-features-in-3-0-0">3.1.3. New Features in 3.0.0</a>
<ul class="sectlevel4">
<li><a href="#improved-mapper-access">Improved Mapper Access</a></li>
</ul>
</li>
<li><a href="#compatibility">3.1.4. Compatibility</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#server-side-support">4. Server-Side Support</a>
<ul class="sectlevel2">
<li><a href="#representation-models">4.1. Representation Models</a></li>
<li><a href="#links">4.2. Links</a></li>
<li><a href="#link-placement">4.3. Link Placement</a>
<ul class="sectlevel3">
<li><a href="#document-level-links-default">4.3.1. Document Level Links (Default)</a></li>
<li><a href="#resource-level-links">4.3.2. Resource Level Links</a></li>
</ul>
</li>
<li><a href="#annotations">4.4. Annotations</a></li>
<li><a href="#jsonapi-builder">4.5. JSON:API Builder</a>
<ul class="sectlevel3">
<li><a href="#explicit-configuration-of-empty-relationships">4.5.1. Explicit Configuration of Empty Relationships</a></li>
</ul>
</li>
<li><a href="#inclusion">4.6. Inclusion of Related Resources</a></li>
<li><a href="#Nesting">4.7. Nesting of JsonApiModels</a></li>
<li><a href="#sparse-fielsets">4.8. Sparse Fieldsets</a></li>
<li><a href="#affordances">4.9. Spring HATEOAS Affordances</a></li>
<li><a href="#Creating">4.10. Creating Resources with HTTP POST</a></li>
<li><a href="#server-deserialization">4.11. Deserialization of JSON:API Types</a></li>
<li><a href="#collection-model-deserialization">4.12. Deserialization of PagedModels</a></li>
<li><a href="#uuid">4.13. UUID Deserialization</a></li>
<li><a href="#polymorphy">4.14. Polymorphic Deserialization</a>
<ul class="sectlevel3">
<li><a href="#jackson-annotations">4.14.1. Jackson Annotations</a></li>
</ul>
</li>
<li><a href="#error-handling">4.15. Error Handling</a>
<ul class="sectlevel3">
<li><a href="#more-generic-error-handling">4.15.1. More Generic Error Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#client-side-support">5. Client-Side Support</a>
<ul class="sectlevel2">
<li><a href="#deserialization">5.1. Deserialization</a></li>
<li><a href="#rest-clients">5.2. REST Clients</a>
<ul class="sectlevel3">
<li><a href="#restclient">5.2.1. RestClient (Spring Boot 4+)</a></li>
<li><a href="#resttemplate">5.2.2. RestTemplate (Legacy)</a></li>
<li><a href="#postWithNoId">5.2.3. Creating POST requests without serialized JSON:API id</a></li>
</ul>
</li>
<li><a href="#traverson">5.3. Traverson</a></li>
<li><a href="#link-discovery">5.4. Link Discovery</a></li>
</ul>
</li>
<li><a href="#configuration">6. Configuration</a>
<ul class="sectlevel2">
<li><a href="#link-placement-configuration-example">6.1. Link Placement Configuration Example</a></li>
<li><a href="#json-mapper-customization">6.2. JSON Mapper Customization</a>
<ul class="sectlevel3">
<li><a href="#example-basic-mapper-customization">6.2.1. Example: Basic Mapper Customization</a></li>
<li><a href="#example-multiple-customizations">6.2.2. Example: Multiple Customizations</a>
<ul class="sectlevel4">
<li><a href="#accessing-the-configured-mapper">Accessing the Configured Mapper</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This project provides JSON:API media type support for Spring HATEOAS.</p>
</div>
<div class="paragraph">
<p>&#169; 2025 The original authors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Copies of this document may be made for your own use and for distribution to others,
provided that you do not charge any fee for such copies and further provided that each copy
contains this Copyright Notice, whether distributed in print or electronically.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="project-metadata"><a class="anchor" href="#project-metadata"></a>Project Metadata</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Version control: <a href="https://github.com/toedter/spring-hateoas-jsonapi" class="bare">github.com/toedter/spring-hateoas-jsonapi</a></p>
</li>
<li>
<p>Bugtracker: <a href="https://github.com/toedter/spring-hateoas-jsonapi/issues" class="bare">github.com/toedter/spring-hateoas-jsonapi/issues</a></p>
</li>
<li>
<p>Release repository: <a href="https://mvnrepository.com/artifact/com.toedter/spring-hateoas-jsonapi">Maven Central</a></p>
</li>
<li>
<p>Snapshot repository: <a href="https://central.sonatype.com/repository/maven-snapshots/">Maven Central Snapshots Repository</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="fundamentals"><a class="anchor" href="#fundamentals"></a>1.1. Fundamentals</h3>
<div class="paragraph">
<p>JSON:API for Spring HATEOAS is based on version 3.0.0 of Spring HATEOAS.
For better understanding of this document, please familiarize yourself with both:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <a href="https://docs.spring.io/spring-hateoas/docs/3.0.0/reference/html/">Spring HATEOAS documentation</a></p>
</li>
<li>
<p>the <a href="https://jsonapi.org/format/">JSON:API Specification</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This documentation assumes that readers are familiar with the above documents.
Some parts of the Java code examples are folded; click on the icon in the bottom-right corner
to expand and view the full source code.</p>
</div>
</div>
<div class="sect2">
<h3 id="jsonapi"><a class="anchor" href="#jsonapi"></a>1.2. JSON:API</h3>
<div class="paragraph">
<p><a href="https://jsonapi.org/">JSON:API</a> is a widely adopted hypermedia format.
You can find a list of implementations and tools <a href="https://jsonapi.org/implementations/">here</a>.
For answers to frequently asked questions (e.g., related to HAL), see
<a href="https://jsonapi.org/faq/#why-not-use-the-hal-specification">here</a>.</p>
</div>
<div class="paragraph">
<p>Anytime a client supplies an <code>Accept</code> header with <code>application/vnd.api+json</code>, you can expect something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "jsonapi": {
    "version": "1.1"
  },
  "data": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "The Shawshank Redemption",
        "year": 1994,
        "rating": 9.3
      },
      "relationships": {
        "directors": {
          "data": [
            {
              "id": "2",
              "type": "directors"
            }
          ],
          "links": {
            "self": "http://localhost:8080/api/movies/1/relationships/directors",
            "related": "http://localhost:8080/api/movies/1/directors"
          }
        }
      },
      "links": {
        "self": "http://localhost:8080/api/movies/1"
      }
    }
  ],
  "included": [
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Frank Darabont"
      }
    }
  ],
  "links": {
    "self": "http://localhost:8080/api/movies?page%5Bnumber%5D=0&amp;page%5Bsize%5D=1",
    "next": "http://localhost:8080/api/movies?page%5Bnumber%5D=1&amp;page%5Bsize%5D=1",
    "last": "http://localhost:8080/api/movies?page%5Bnumber%5D=249&amp;page%5Bsize%5D=1"
  },
  "meta": {
    "page": {
      "size": 1,
      "totalElements": 250,
      "totalPages": 250,
      "number": 0
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The characters <code>[</code> and <code>]</code> in the Links section are unsafe and URL encoded when added automatically by the
library. So the URL decoded next link would look like: http://localhost:8080/api/movies?page[number]=1&amp;page[size]=1.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setup"><a class="anchor" href="#setup"></a>2. Setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To enable the JSON:API media type, simply add this module as a dependency to your project.</p>
</div>
<div class="listingblock primary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">implementation 'com.toedter:spring-hateoas-jsonapi:3.0.0'
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.toedter&lt;/groupId&gt;
    &lt;artifactId&gt;spring-hateoas-jsonapi&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The latest published snapshot version is <code>3.0.1-SNAPSHOT</code>.</p>
</div>
<div class="sect2">
<h3 id="version-requirements"><a class="anchor" href="#version-requirements"></a>2.1. Version Requirements</h3>
<div class="paragraph">
<p>This library requires:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Spring Boot 4.x</strong> (Spring Framework 7.x)</p>
</li>
<li>
<p><strong>Jackson 3.x</strong> (tools.jackson.*)</p>
</li>
<li>
<p><strong>Java 17 or later</strong></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Version 3.0.0 is the first version based on Spring Boot 4 and Jackson 3. The last version supporting Spring Boot 3 is 2.2.0.</p>
</div>
<div class="paragraph">
<p>This is a breaking change if you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Use deprecated APIs</strong>: All deprecated APIs have been <strong>removed</strong> (<code>withJsonApiVersionRendered()</code> and <code>withObjectMapperCustomizer()</code>)</p>
</li>
<li>
<p>Use custom Jackson serializers/deserializers with the old <code>com.fasterxml.jackson.*</code> package</p>
</li>
<li>
<p>Directly interact with the Jackson <code>ObjectMapper</code> API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Jackson 3 API uses the <code>tools.jackson.<strong></code> package namespace instead of <code>com.fasterxml.jackson.</strong></code>.</p>
</div>
<div class="paragraph">
<p>See the <a href="#migration-3-0-0">Migration Guide</a> for detailed migration instructions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="migration"><a class="anchor" href="#migration"></a>3. Migration Guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="migration-3-0-0"><a class="anchor" href="#migration-3-0-0"></a>3.1. Migrating to Version 3.0.0</h3>
<div class="paragraph">
<p>Version 3.0.0 is the first release based on Spring Boot 4 and Jackson 3. The last version supporting Spring Boot 3 is 2.2.0.
This section provides guidance for migrating from version 2.x to 3.0.0.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Version 3.0.0 <strong>removes all deprecated APIs</strong> from version 2.x.x. Code using deprecated APIs will <strong>not compile</strong>.
See the <a href="#removed-deprecated-apis">Removed Deprecated APIs</a> section for migration instructions.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="breaking-changes"><a class="anchor" href="#breaking-changes"></a>3.1.1. Breaking Changes</h4>
<div class="sect4">
<h5 id="removed-deprecated-apis"><a class="anchor" href="#removed-deprecated-apis"></a>Removed Deprecated APIs</h5>
<div class="paragraph">
<p>Version 3.0.0 <strong>removes</strong> all deprecated APIs from version 2.x.x and also changes the mapper customization. You <strong>must</strong> migrate to the new APIs:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Removed API</strong></th>
<th class="tableblock halign-left valign-top"><strong>Replacement</strong></th>
<th class="tableblock halign-left valign-top"><strong>Section</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>withJsonApiVersionRendered(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>withJsonApiObject(JsonApiObject)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jsonapi-version-rendering">JSON:API Version Rendering</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>withObjectMapperCustomizer(Function&lt;ObjectMapper, ObjectMapper&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>withMapperCustomizer(UnaryOperator&lt;JsonMapper.Builder&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#json-mapper-customization">JSON Mapper Customization</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Action Required</strong>: If your code uses any of the removed APIs listed above, it will <strong>not compile</strong> with version 3.0.0.
You must update to use the new replacement APIs before upgrading.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-boot-4-and-spring-framework-7"><a class="anchor" href="#spring-boot-4-and-spring-framework-7"></a>Spring Boot 4 and Spring Framework 7</h5>
<div class="paragraph">
<p>Version 3.0.0 requires Spring Boot 4.x and Spring Framework 7.x. Key changes include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Minimum Java version</strong>: Java 17 (unchanged from 2.1.x)</p>
</li>
<li>
<p><strong>Jakarta EE namespace</strong>: Uses <code>jakarta.<strong></code> packages instead of <code>javax.</strong></code></p>
</li>
<li>
<p><strong>RestTemplate removed</strong>: Use <code>RestClient</code> instead for HTTP client operations</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="jackson-3-migration"><a class="anchor" href="#jackson-3-migration"></a>Jackson 3 Migration</h5>
<div class="paragraph">
<p>The most significant breaking change is the migration from Jackson 2 to Jackson 3.</p>
</div>
<div class="sect5">
<h6 id="package-changes"><a class="anchor" href="#package-changes"></a>Package Changes</h6>
<div class="paragraph">
<p>Jackson 3 uses a new package namespace:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jackson 2 (Old)</th>
<th class="tableblock halign-left valign-top">Jackson 3 (New)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.databind.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tools.jackson.databind.*</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.core.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tools.jackson.core.*</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.annotation.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.annotation.*</code> <em>(unchanged)</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="api-changes"><a class="anchor" href="#api-changes"></a>API Changes</h6>
<div class="ulist">
<ul>
<li>
<p><strong>ObjectMapper → JsonMapper</strong>: The <code>JsonMapper</code> class is now preferred over <code>ObjectMapper</code></p>
</li>
<li>
<p><strong>Custom Serializers/Deserializers</strong>: Must extend Jackson 3 base classes from <code>tools.jackson.*</code> packages</p>
</li>
<li>
<p><strong>Module Registration</strong>: Modules must be compatible with Jackson 3</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="jsonapi-version-rendering"><a class="anchor" href="#jsonapi-version-rendering"></a>JSON:API Version Rendering</h6>
<div class="paragraph">
<p><strong>IMPORTANT</strong>: The deprecated <code>withJsonApiVersionRendered()</code> API has been <strong>removed</strong> in version 3.0.0.
You <strong>must</strong> migrate to the new <code>withJsonApiObject()</code> API.</p>
</div>
<div class="paragraph">
<p>If you were using the <code>jsonApiVersionRendered</code> configuration:</p>
</div>
<div class="listingblock">
<div class="title">Before (Version 2.x.x - Spring Boot 3)</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
        .withJsonApiVersionRendered(true);  <i class="conum" data-value="1"></i><b>(1)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>REMOVED</strong> in version 3.0.0 - this will no longer compile</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">After (Version 3.0.0 - Spring Boot 4) - <strong>REQUIRED</strong></div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
        .withJsonApiObject(new JsonApiObject(true, null, null, null));  <i class="conum" data-value="1"></i><b>(1)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use <code>withJsonApiObject(new JsonApiObject(true, &#8230;&#8203;))</code> instead of the removed <code>withJsonApiVersionRendered(true)</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>JsonApiObject</code> provides much more flexibility and allows you to configure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>version</strong>: The JSON:API version (e.g., "1.1")</p>
</li>
<li>
<p><strong>ext</strong>: List of JSON:API extensions</p>
</li>
<li>
<p><strong>profile</strong>: List of JSON:API profiles</p>
</li>
<li>
<p><strong>meta</strong>: Metadata for the JSON:API object</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example with all options</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JsonApiConfiguration jsonApiConfiguration() {
    JsonApiObject jsonApiObject = new JsonApiObject(
        true,  // showVersion
        List.of(URI.create("https://jsonapi.org/ext/atomic")),  // extensions
        List.of(URI.create("http://example.com/profiles/flexible-pagination")),  // profiles
        Map.of("copyright", "Copyright 2025")  // meta
    );

    return new JsonApiConfiguration()
        .withJsonApiObject(jsonApiObject);
}
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mapper-customization"><a class="anchor" href="#mapper-customization"></a>Mapper Customization</h6>
<div class="paragraph">
<p><strong>IMPORTANT</strong>: The deprecated <code>withObjectMapperCustomizer()</code> API has been <strong>removed</strong> in version 3.0.0.
You <strong>must</strong> migrate to the new <code>withMapperCustomizer()</code> API.</p>
</div>
<div class="paragraph">
<p>If you were using the <code>ObjectMapperCustomizer</code> configuration:</p>
</div>
<div class="listingblock">
<div class="title">Before (Version 2.x.x - Spring Boot 3)</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
        .withObjectMapperCustomizer(mapper -&gt; {  <i class="conum" data-value="1"></i><b>(1)</b>
            mapper.enable(SerializationFeature.INDENT_OUTPUT);
            return mapper;
        });
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>REMOVED</strong> in version 3.0.0 - this will no longer compile</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">After (Version 3.0.0 - Spring Boot 4) - <strong>REQUIRED</strong></div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
        .withMapperCustomizer(builder -&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
            builder.enable(SerializationFeature.INDENT_OUTPUT)  <i class="conum" data-value="2"></i><b>(2)</b>
        );
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use <code>withMapperCustomizer</code> instead of the removed <code>withObjectMapperCustomizer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Works with <code>JsonMapper.Builder</code> instead of <code>ObjectMapper</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-serializers-and-deserializers"><a class="anchor" href="#custom-serializers-and-deserializers"></a>3.1.2. Custom Serializers and Deserializers</h4>
<div class="paragraph">
<p>If you have custom Jackson serializers or deserializers, you need to update them:</p>
</div>
<div class="listingblock">
<div class="title">Before (Jackson 2)</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;

public class CustomSerializer extends StdSerializer&lt;MyType&gt; {
    @Override
    public void serialize(MyType value, JsonGenerator gen,
                         SerializerProvider provider) {
        // serialization logic
    }
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">After (Jackson 3)</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import tools.jackson.core.JsonGenerator;
import tools.jackson.databind.SerializationContext;  <i class="conum" data-value="1"></i><b>(1)</b>
import tools.jackson.databind.ValueSerializer;  <i class="conum" data-value="2"></i><b>(2)</b>

public class CustomSerializer extends ValueSerializer&lt;MyType&gt; {  <i class="conum" data-value="3"></i><b>(3)</b>
    @Override
    public void serialize(MyType value, JsonGenerator gen,
                         SerializationContext ctxt) {  <i class="conum" data-value="4"></i><b>(4)</b>
        // serialization logic (unchanged)
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use <code>SerializationContext</code> instead of <code>SerializerProvider</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>ValueSerializer</code> instead of <code>JsonSerializer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Extend <code>ValueSerializer</code> instead of <code>StdSerializer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Parameter type changed from <code>SerializerProvider</code> to <code>SerializationContext</code></td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="resttemplate-restclient"><a class="anchor" href="#resttemplate-restclient"></a>RestTemplate → RestClient</h5>
<div class="paragraph">
<p>As of Spring Framework 7.0, RestTemplate is deprecated in favor of RestClient and will be removed in a future version.
For HTTP client testing, migrate from <code>TestRestTemplate</code> to <code>RestTestClient</code>:</p>
</div>
<div class="listingblock">
<div class="title">Before (TestRestTemplate )</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
private TestRestTemplate restTemplate;

ResponseEntity&lt;String&gt; response = restTemplate.exchange(
    "/api/movies/1",
    HttpMethod.GET,
    entity,
    String.class
);
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">After (RestTestClient)</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
private RestTestClient restClient;

String response = restClient.get()
    .uri("/api/movies/1")
    .header("Accept", MediaTypes.JSON_API_VALUE)
    .exchange()
    .returnResult(String.class)
    .getResponseBody();
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="new-features-in-3-0-0"><a class="anchor" href="#new-features-in-3-0-0"></a>3.1.3. New Features in 3.0.0</h4>
<div class="sect4">
<h5 id="improved-mapper-access"><a class="anchor" href="#improved-mapper-access"></a>Improved Mapper Access</h5>
<div class="paragraph">
<p>Direct access to the configured JsonMapper:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JsonApiConfiguration config = new JsonApiConfiguration()
    .withMapperCustomizer(builder -&gt;
        builder.enable(SerializationFeature.INDENT_OUTPUT)
    );

JsonMapper mapper = config.getJsonMapper();  <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Obtain a fully configured <code>JsonMapper</code> instance</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="compatibility"><a class="anchor" href="#compatibility"></a>3.1.4. Compatibility</h4>
<div class="paragraph">
<p>Version 3.0.0 is a major version release due to the Spring Boot 4 and Jackson 3 migration.
The main breaking changes are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Removed deprecated APIs</strong>: All deprecated APIs from version 2.x.x have been removed - you must migrate to the new APIs:</p>
<div class="ulist">
<ul>
<li>
<p><code>withJsonApiVersionRendered()</code> → <code>withJsonApiObject()</code></p>
</li>
<li>
<p><code>withObjectMapperCustomizer()</code> → <code>withMapperCustomizer()</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Spring Boot 4</strong> requirement (upgraded from Spring Boot 3 in version 2.x.x)</p>
</li>
<li>
<p><strong>Jackson 3</strong> package namespace changes (affects custom serializers/deserializers)</p>
</li>
<li>
<p>Spring Boot 4 testing API changes (<code>@AutoConfigureMockMvc</code>, <code>RestTemplate</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Migration Required</strong>: If you were using any of the deprecated APIs (<code>withJsonApiVersionRendered()</code> or
<code>withObjectMapperCustomizer()</code>), your code will not compile with version 3.0.0. You must update your code to use the
new APIs (<code>withJsonApiObject()</code> and <code>withMapperCustomizer()</code>) before upgrading.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t use the removed deprecated APIs or custom Jackson code, and don&#8217;t directly interact with Spring Boot
testing internals, migration should be straightforward - mainly requiring updates to Spring Boot 4 compatible dependency versions.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-side-support"><a class="anchor" href="#server-side-support"></a>4. Server-Side Support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="representation-models"><a class="anchor" href="#representation-models"></a>4.1. Representation Models</h3>
<div class="paragraph">
<p>All Spring HATEOAS representation models are rendered as JSON:API.
Consider a simple Movie class as the base for a Spring HATEOAS entity model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class Movie {

  private String id;
  private String title;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>EntityModel.of(new Movie("1", "Star Wars"))</code> is then rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In JSON:API, the <code>id</code> field must be of type <code>String</code>.
However, in your model you can use any class, and <code>toString()</code> is used for conversion.
So, if the <code>id</code> attribute of <code>Movie</code> were of type <code>long</code>,
the rendered JSON:API output would be the same.
The JSON:API <code>type</code> is automatically generated from the pluralized, lowercase, simple class name.
This is a best practice, as the type will most likely match the URL (endpoint)
of the corresponding REST collection resource.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can configure if you want to use non-pluralized class names, see <a href="#configuration">Configuration</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="links"><a class="anchor" href="#links"></a>4.2. Links</h3>
<div class="paragraph">
<p>If Spring HATEOAS links contain only an href, the simple JSON:API link format is used for rendering.
Here is an example of a simple self link:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": "http://localhost/movies/1"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A complex Link object in Spring HATEOAS can have optional properties like name, type, hreflang, title, and others.
In previous versions of this library, those properties were serialized as JSON:API link metadata, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": {
      "href": "https://complex-links.org",
      "meta": {
        "hreflang": "EN",
        "media": "media",
        "title": "title",
        "type": "type",
        "name": "name"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON:API 1.1 now defines the optional link properties type, title, and hreflang, see <a href="https://jsonapi.org/format/#auto-id--link-objects">JSON:API Link Objects</a>.
The default rendering of a complex link is now</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": {
      "href": "https://complex-links.org",
      "title": "title",
      "type": "type",
      "hreflang": "EN",
      "meta": {
        "media": "media",
        "name": "name"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the properties title, type, and hreflang now appear only as top-level link properties.
The new format reflects the JSON:API 1.1 link structure,
but is <em>not</em> backward compatible with version 1.x.x of this library.</p>
</div>
<div class="paragraph">
<p>If you want to maintain backward compatibility and render the link properties type, title, and hreflang
both as top-level link properties <em>and</em> in the meta section, you can configure this behavior
(see <a href="#links-configuration">[links-configuration]</a>). The rendered result would then look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": {
      "href": "https://complex-links.org",
      "title": "title",
      "type": "type",
      "hreflang": "EN",
      "meta": {
        "hreflang": "EN",
        "media": "media",
        "title": "title",
        "type": "type",
        "name": "name"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON:API is very strict about the allowed link relations, the allowed
<a href="https://jsonapi.org/format/#document-top-level">top-level links</a> are
<code>self</code>, <code>related</code>, <code>describedBy</code>, <code>next</code>, <code>prev</code>, <code>first</code> and <code>last</code>. The only allowed
<a href="https://jsonapi.org/format/#document-resource-object-links">resource link</a> is <code>self</code>.</p>
</div>
<div class="paragraph">
<p>By default, all other links will <em>not</em> be serialized. If you want to serialize links that are non-compliant
with JSON:API, you can use a specific configuration, (see <a href="#links-configuration">[links-configuration]</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="link-placement"><a class="anchor" href="#link-placement"></a>4.3. Link Placement</h3>
<div class="paragraph">
<p>The JSON:API specification allows links to be placed at two different levels in the document:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Document level (top-level)</strong> - Links appear at the top level of the JSON document (default behavior)</p>
</li>
<li>
<p><strong>Resource level</strong> - Links appear inside the resource object within the "data" section</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, this library places links at the document level for single resource (EntityModel) serialization.
However, you can configure this behavior using the <code>LinksAtResourceLevel</code> configuration option
(see <a href="#links-placement-configuration">[links-placement-configuration]</a>).</p>
</div>
<div class="sect3">
<h4 id="document-level-links-default"><a class="anchor" href="#document-level-links-default"></a>4.3.1. Document Level Links (Default)</h4>
<div class="paragraph">
<p>When using the default configuration, links from an EntityModel are placed at the document level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
EntityModel&lt;Movie&gt; entityModel = EntityModel.of(movie);
entityModel.add(Link.of("http://localhost/movies/1").withSelfRel());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This produces the following JSON:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": "http://localhost/movies/1"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resource-level-links"><a class="anchor" href="#resource-level-links"></a>4.3.2. Resource Level Links</h4>
<div class="paragraph">
<p>To place links at the resource level instead, configure <code>LinksAtResourceLevel</code> to <code>true</code> (See <a href="#link-placement-configuration-example">Link Placement Configuration Example</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
EntityModel&lt;Movie&gt; entityModel = EntityModel.of(movie);
entityModel.add(Link.of("http://localhost/movies/1").withSelfRel());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This produces the following JSON:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "links": {
      "self": "http://localhost/movies/1"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This configuration only affects single resource (EntityModel) serialization. Collection models (CollectionModel)
and paged models (PagedModel) are not affected by this setting.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both approaches are valid according to the JSON:API specification. Choose the approach that best fits your API design:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Document level</strong> - Common pattern, provides clear separation between document metadata and resource data</p>
</li>
<li>
<p><strong>Resource level</strong> - Keeps all resource-related information co-located, which some API consumers may prefer</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations"><a class="anchor" href="#annotations"></a>4.4. Annotations</h3>
<div class="paragraph">
<p>The goal of this implementation is to automate the mapping to/from JSON:API
as conveniently as possible.</p>
</div>
<div class="paragraph">
<p>This project provides four annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@JsonApiId</code> to mark a JSON:API <code>id</code></p>
</li>
<li>
<p><code>@JsonApiType</code> to mark a field or method to provide a JSON:API <code>type</code></p>
</li>
<li>
<p><code>@JsonApiTypeForClass</code> to mark class to provide a JSON:API <code>type</code></p>
<div class="ulist">
<ul>
<li>
<p>The JSON:API type is a required value of this annotation</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@JsonApiRelationships</code> to mark a JSON:API <code>relationship</code></p>
<div class="ulist">
<ul>
<li>
<p>This annotation is not used for serialization but deserialization,
see <a href="#Creating">Creating Resources with HTTP POST</a> for an example.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@JsonApiMeta</code> to mark a field or method to provide a JSON:API <code>meta</code> information</p>
<div class="ulist">
<ul>
<li>
<p>This annotation works for serialization and deserialization.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The use of these annotations is optional. For the mapping of the <code>id</code>, the
following rules apply in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the annotation <code>@JsonApiId</code> is used on a field</p>
</li>
<li>
<p>the annotation <code>@JsonApiId</code> is used on a method</p>
</li>
<li>
<p>the annotation <code>@Id</code> (jakarta.persistence.Id) is used on a field</p>
</li>
<li>
<p>the annotation <code>@Id</code> (jakarta.persistence.Id) is used on a method</p>
</li>
<li>
<p>the entity (base for representation models) provides an attribute <code>id</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the mapping of the <code>type</code>, the
following rules apply in order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the annotation <code>@JsonApiTypeForClass</code> is used on a class</p>
</li>
<li>
<p>the annotation <code>@JsonApiType</code> is used on a field</p>
</li>
<li>
<p>the annotation <code>@JsonApiType</code> is used on a method</p>
</li>
<li>
<p>if no annotation is present, the pluralized, lower case, simple class name of the entity will be used</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can configure if you want to use non-pluralized class names, see <a href="#configuration">Configuration</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As an example, consider the class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor

</span><span class="fold-block">public class MovieWithAnnotations {

  @Id private String myId;

  @JsonApiType private String type;

  @JsonApiMeta private String myMeta;

  private String title;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, <code>EntityModel.of(new MovieWithAnnotations("1", "my-movies", "metaValue", "Star Wars")))</code> will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "my-movies",
    "attributes": {
      "title": "Star Wars"
    },
    "meta": {
      "myMeta": "metaValue"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jsonapi-builder"><a class="anchor" href="#jsonapi-builder"></a>4.5. JSON:API Builder</h3>
<div class="paragraph">
<p>If you want to use JSON:API <code>relationships</code> or <code>included</code> data, you can use the
<code>JsonApiModelBuilder</code>. The following example shows how to create a JSON:API representation model using the <code>JsonApiModelBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static com.toedter.spring.hateoas.jsonapi.JsonApiModelBuilder.jsonApiModel;
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
final RepresentationModel&lt;?&gt; jsonApiModel = jsonApiModel().model(movie).build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider that you want to express the relationships of movies to their directors.
A simple <code>Director</code> class could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class Director {

  private String id;
  private String name;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can build a relationship from a movie to a director like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "Star Wars");
Director director = new Director("1", "George Lucas");

final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel().model(movie).relationship("directors", director).build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The representation model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "relationships": {
      "directors": {
        "data": {
          "id": "1",
          "type": "directors"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want the <code>directors</code> relationship to always be rendered as an array,
even if it is empty or contains only a single data element,
you can build it like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel()
        .model(EntityModel.of(movie))
        .relationshipWithDataArray("directors")
        .relationship("directors", director)
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The representation model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "relationships": {
      "directors": {
        "data": [
          {
            "id": "3",
            "type": "directors"
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also pass a Java <code>Collection</code> as data for a relationship.
A collection will always be rendered as a JSON array,
even when it is empty or contains a single element.
So,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel()
        .model(EntityModel.of(movie))
        .relationship("directors", Collections.singletonList(director))
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be rendered exactly like the previous example.</p>
</div>
<div class="paragraph">
<p>The builder also provides methods for adding links and meta to a relationship.
Check out the <a href="../api/com/toedter/spring/hateoas/jsonapi/JsonApiModelBuilder.html">Javadoc API documentation</a>
for more details.</p>
</div>
<div class="paragraph">
<p>If you want to include the related resources in the JSON:API output,
you can build included <code>director</code> resources like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "The Matrix");
Movie relatedMovie = new Movie("2", "The Matrix 2");
Director director1 = new Director("1", "Lana Wachowski");
Director director2 = new Director("2", "Lilly Wachowski");

final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel()
        .model(movie)
        .relationship("directors", director1)
        .relationship("directors", director2)
        .relationship("relatedMovies", relatedMovie)
        .included(director1)
        .included(director2)
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The representation model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "The Matrix"
    },
    "relationships": {
      "relatedMovies": {
        "data": {
          "id": "2",
          "type": "movies"
        }
      },
      "directors": {
        "data": [
          {
            "id": "1",
            "type": "directors"
          },
          {
            "id": "2",
            "type": "directors"
          }
        ]
      }
    }
  },
  "included": [
    {
      "id": "1",
      "type": "directors",
      "attributes": {
        "name": "Lana Wachowski"
      }
    },
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Lilly Wachowski"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the creation of a more complex
JSON:API specific representation model with a paged model as the base.
The builder supports adding both pagination metadata and pagination links.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("1", "The Matrix");
Movie relatedMovie = new Movie("2", "The Matrix 2");
Director director1 = new Director("1", "Lana Wachowski");
Director director2 = new Director("2", "Lilly Wachowski");

final RepresentationModel&lt;?&gt; jsonApiModel1 =
    jsonApiModel()
        .model(movie)
        .relationship("directors", director1)
        .relationship("directors", director2)
        .relationship("relatedMovies", EntityModel.of(relatedMovie))
        .build();

Movie movie2 = new Movie("3", "Star Wars");
Director director3 = new Director("3", "George Lucas");

final RepresentationModel&lt;?&gt; jsonApiModel2 =
    jsonApiModel().model(movie2).relationship("directors", director3).build();

List&lt;RepresentationModel&lt;?&gt;&gt; movies = new ArrayList&lt;&gt;();
movies.add(jsonApiModel1);
movies.add(jsonApiModel2);

PagedModel.PageMetadata pageMetadata = new PagedModel.PageMetadata(10, 1, 100, 10);
Link selfLink = Link.of("http://localhost/movies").withSelfRel();
final PagedModel&lt;RepresentationModel&lt;?&gt;&gt; pagedModel =
    PagedModel.of(movies, pageMetadata, selfLink);

RepresentationModel&lt;?&gt; pagedJasonApiModel =
    jsonApiModel()
        .model(pagedModel)
        .included(director1)
        .included(director2)
        .included(director3)
        .pageMeta()
        .pageLinks("http://localhost/movies")
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "The Matrix"
      },
      "relationships": {
        "relatedMovies": {
          "data": {
            "id": "2",
            "type": "movies"
          }
        },
        "directors": {
          "data": [
            {
              "id": "1",
              "type": "directors"
            },
            {
              "id": "2",
              "type": "directors"
            }
          ]
        }
      }
    },
    {
      "id": "3",
      "type": "movies",
      "attributes": {
        "title": "Star Wars"
      },
      "relationships": {
        "directors": {
          "data": {
            "id": "3",
            "type": "directors"
          }
        }
      }
    }
  ],
  "included": [
    {
      "id": "1",
      "type": "directors",
      "attributes": {
        "name": "Lana Wachowski"
      }
    },
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Lilly Wachowski"
      }
    },
    {
      "id": "3",
      "type": "directors",
      "attributes": {
        "name": "George Lucas"
      }
    }
  ],
  "links": {
    "self": "http://localhost/movies",
    "first": "http://localhost/movies?page%5Bnumber%5D=0&amp;page%5Bsize%5D=10",
    "prev": "http://localhost/movies?page%5Bnumber%5D=0&amp;page%5Bsize%5D=10",
    "next": "http://localhost/movies?page%5Bnumber%5D=2&amp;page%5Bsize%5D=10",
    "last": "http://localhost/movies?page%5Bnumber%5D=9&amp;page%5Bsize%5D=10"
  },
  "meta": {
    "page": {
      "size": 10,
      "totalElements": 100,
      "totalPages": 10,
      "number": 1
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="explicit-configuration-of-empty-relationships"><a class="anchor" href="#explicit-configuration-of-empty-relationships"></a>4.5.1. Explicit Configuration of Empty Relationships</h4>
<div class="paragraph">
<p>The JSON:API specification allows empty to-one relationships and empty to-many relationships
(see <a href="https://jsonapi.org/format/#document-resource-object-linkage">JSON:API specification</a>).</p>
</div>
<div class="paragraph">
<p>For more explicit control over the serialization of empty relationships, you can use
<code>relationshipWithNullData()</code> to create an empty to-one relationship (serialized as <code>"data": null</code>)
or <code>relationshipWithEmptyData()</code> to create an empty to-many relationship (serialized as <code>"data": []</code>).</p>
</div>
<div class="paragraph">
<p>An explicit empty to-one relationship can be added like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel().model(EntityModel.of(movie)).relationshipWithNullData("directors").build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will produce <code>"data": null</code> in the relationship object, representing an empty to-one relationship.</p>
</div>
<div class="paragraph">
<p>An explicit empty to-many relationship can be added like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel().model(EntityModel.of(movie)).relationshipWithEmptyData("directors").build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will produce <code>"data": []</code> in the relationship object, representing an empty to-many relationship.</p>
</div>
<div class="paragraph">
<p>These methods are particularly useful when you want to replace existing relationship data with null or an empty array,
or when you need to explicitly indicate the type of empty relationship (to-one vs. to-many) for your JSON:API consumers.
These methods also preserve any existing links and meta information in the relationship.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inclusion"><a class="anchor" href="#inclusion"></a>4.6. Inclusion of Related Resources</h3>
<div class="paragraph">
<p>There is no direct support for automatically including related resources,
but a REST controller can provide an optional request parameter like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestParam(value = "include", required = false) String[] include
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, within the controller implementation, this parameter can be interpreted,
and the builder can be used for the inclusion, like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">if (include != null &amp;&amp; include.length == 1 &amp;&amp; include[0].equals(DIRECTORS)) {
  for (Movie movie : pagedResult.getContent()) {
    jsonApiModelBuilder.included(movie.getDirectors());
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Duplicated included directors will be eliminated automatically.</p>
</div>
</div>
<div class="sect2">
<h3 id="Nesting"><a class="anchor" href="#Nesting"></a>4.7. Nesting of JsonApiModels</h3>
<div class="paragraph">
<p>When using the model builder, <code>JsonApiModel</code> instances can be used as the model and included
resources. Here is an example that also illustrates the different levels of meta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Director director = new Director("3", "George Lucas");
final RepresentationModel&lt;?&gt; directorModel =
    jsonApiModel()
        .model(EntityModel.of(director))
        .meta("director-meta", "director-meta-value")
        .build();

Map&lt;String, Object&gt; relationshipMeta = new HashMap&lt;&gt;();
relationshipMeta.put("relationship-meta", "relationship-meta-value");

Map&lt;String, Object&gt; directorRelationshipMeta = new HashMap&lt;&gt;();
directorRelationshipMeta.put("director-relationship-meta", "director-relationship-meta-value");

Movie movie = new Movie("1", "Star Wars");
final RepresentationModel&lt;?&gt; movieModel =
    jsonApiModel()
        .model(movie)
        .meta("movie-meta", "movie-meta-value")
        .relationship("directors", director, directorRelationshipMeta)
        .relationship("directors", relationshipMeta)
        .build();

final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel()
        .model(movieModel)
        .meta("top-level-meta", "top-level-meta-value")
        .included(directorModel)
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This model will be rendered as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "relationships": {
      "directors": {
        "data": {
          "id": "3",
          "type": "directors",
          "meta": {
            "director-relationship-meta": "director-relationship-meta-value"
          }
        },
        "meta": {
          "relationship-meta": "relationship-meta-value"
        }
      }
    },
    "meta": {
      "movie-meta": "movie-meta-value"
    }
  },
  "included": [
    {
      "id": "3",
      "type": "directors",
      "attributes": {
        "name": "George Lucas"
      },
      "meta": {
        "director-meta": "director-meta-value"
      }
    }
  ],
  "meta": {
    "top-level-meta": "top-level-meta-value"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sparse-fielsets"><a class="anchor" href="#sparse-fielsets"></a>4.8. Sparse Fieldsets</h3>
<div class="paragraph">
<p>Sparse fieldsets are supported for attributes within <code>data</code> and <code>included</code>. You can add sparse fieldsets
using the <code>JsonApiBuilder</code>. The following example illustrates the build, assuming a director has
the attributes <code>name</code> and <code>born</code>, and a movie has the attributes <code>title</code> and <code>rating</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MovieWithRating movie = new MovieWithRating("1", "Star Wars", 8.6);
DirectorWithMovies director = new DirectorWithMovies("3", "George Lucas", 1944);
director.setMovies(Collections.singletonList(movie));

final RepresentationModel&lt;?&gt; jsonApiModel =
    jsonApiModel()
        .model(EntityModel.of(director))
        .fields("directors", "name")
        .fields("movies", "title")
        .relationship("movies", movie)
        .included(movie)
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, only the name attribute of a director, and the title attribute
of a movie would be serialized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "3",
    "type": "directors",
    "attributes": {
      "name": "George Lucas"
    },
    "relationships": {
      "movies": {
        "data": {
          "id": "1",
          "type": "movies"
        }
      }
    }
  },
  "included": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "Star Wars"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a REST controller, a method with HTTP-mapping can provide an optional request parameter for each sparse fieldset
that should be applied to a specific JSON:API type, like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestParam(value = "fields[movies]", required = false) String[] fieldsMovies,
@RequestParam(value = "fields[directors]", required = false) String[] fieldsDirectors)
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following controller code, you could check the existence of these request parameters, like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">if (fieldsDirectors != null) {
    builder = builder.fields("directors", fieldsDirectors);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>When adding sparse fieldsets to the builder, they will NOT automatically exclude added relationships.
Relationships have to be added conditionally, like the inclusions, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">if (fieldsDirectors = null || Arrays.asList(fieldsDirectors).contains("movies")) {
    builder = builder.relationship("movies", director.getMovies());
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="affordances"><a class="anchor" href="#affordances"></a>4.9. Spring HATEOAS Affordances</h3>
<div class="paragraph">
<p>Spring HATEOAS provides a generic, media type-independent API for
3.0.0/reference/html/#server.affordances[affordances].
In the JSON:API specification, there is no equivalent concept, but JSON:API allows links to have additional meta
information. This library provides a new <strong>experimental</strong> configuration to render Spring HATEOAS affordances as
JSON:API link meta. Currently, a proprietary format is supported as well as the HAL-FORMS template format,
which can be serialized by Spring HATEOAS out of the box.</p>
</div>
<div class="paragraph">
<p>The following example shows the usage of Spring HATEOAS affordances.
First, you need to enable this experimental feature in the configuration, like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">new JsonApiConfiguration().withAffordancesRenderedAsLinkMeta(
   JsonApiConfiguration.AffordanceType.SPRING_HATEOAS);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can add an affordance (for creating a movie) to a Spring HATEOAS link like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final Affordance newMovieAffordance = afford(methodOn(MovieController.class).newMovie(null));

Link selfLink =
    linkTo(MovieController.class)
        .slash(
            "movies"
                + uriParams
                + "&amp;page[number]="
                + pagedResult.getNumber()
                + "&amp;page[size]="
                + pagedResult.getSize())
        .withSelfRel()
        .andAffordance(newMovieAffordance);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rendered result of the self link would then be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">"links": {
  "self": {
    "href": "http://localhost:8080/api/movies?page[number]=0&amp;page[size]=10",
    "meta": {
      "affordances": [
        {
          "name": "newMovie",
          "link": {
            "rel": "newMovie",
            "href": "http://localhost:8080/api/movies"
          },
          "httpMethod": "POST",
          "inputProperties": [
            {
              "name": "imdbId",
              "type": "text",
            },
            {
              "name": "rank",
              "type": "number",
            },
            {
              "name": "rating",
              "type": "number",
            },
            {
              "name": "title",
              "type": "text",
              "required": true
            },
            {
              "name": "year",
              "type": "number",
            }
          ]
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This feature is experimental. The JSON structure of the provided affordances might have breaking changes in upcoming releases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To obtain property information such as required fields, you must include a dependency on <code>javax.validation:validation-api</code> and annotate the required fields with <code>@NotNull</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="Creating"><a class="anchor" href="#Creating"></a>4.10. Creating Resources with HTTP POST</h3>
<div class="paragraph">
<p>To create new REST resources using HTTP POST, you can provide <code>JSON:API</code> formatted JSON as input.
For example, a <code>POST</code> with the body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "type": "movies",
    "attributes": {
      "title": "Batman Begins"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be deserialized to an <code>EntityModel&lt;Movie&gt;</code> automatically.
You can also create REST resources that contain <code>JSON:API relationships</code>.
You simply need to annotate the underlying domain model class with <code>JsonApiRelationships(&lt;relationship name&gt;)</code>.</p>
</div>
<div class="paragraph">
<p>For example, a <code>POST</code> with the body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "type": "movies",
    "attributes": {
      "title": "New Movie"
    },
    "relationships": {
      "directors": {
        "data": [
          {
            "id": "1",
            "type": "directors"
          },
          {
            "id": "2",
            "type": "directors"
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be deserialized to an <code>EntityModel&lt;Movie&gt;</code> with a filled list of directors,
where only the id attribute of each director is set.
The REST controller must then interpret those relationships and bind the
real director objects to the movie.</p>
</div>
<div class="paragraph">
<p>Here is an example of a class using the annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class MovieWithDirectors extends Movie {

  @JsonApiType String myType = "movies";

  @JsonIgnore
  @JsonApiRelationships("directors")
  List&lt;Director&gt; directors;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to set the attributes of a related director,
you could put the director resource in the included section of the JSON, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    },
    "relationships": {
      "directors": {
        "data": {
          "id": "3",
          "type": "directors"
        }
      }
    }
  },
  "included": [
    {
      "id": "3",
      "type": "directors",
      "attributes": {
        "name": "George Lucas"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, after deserialization the <code>name</code> attribute of the first director is set to "George Lucas".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use the annotation <code>JsonApiRelationships</code> on an attribute of a Java class,
the content will NOT be serialized automatically to <code>JSON:API relationships</code>. This is on purpose,
please use the <code>JsonApiModelBuilder</code> to decide, which relationships and included objects you want to return.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="server-deserialization"><a class="anchor" href="#server-deserialization"></a>4.11. Deserialization of JSON:API Types</h3>
<div class="paragraph">
<p>If entities contain an explicit <code>@JsonApiType</code> field annotation,
those fields are also filled during deserialization.
This is also true for relationships if the relationship entity contains an explicit <code>@JsonApiType</code>
annotation.</p>
</div>
<div class="paragraph">
<p>Consider the following classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class DirectorWithType {

  private String id;
  private String name;

  @JsonApiType private String directorType;
}
</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class MovieWithTypedDirectors {

  private String id;
  private String title;

  @JsonApiType String myType;

  @JsonIgnore
  @JsonApiRelationships("directors")
  List&lt;DirectorWithType&gt; directors;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following JSON</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "type": "movies",
    "attributes": {
      "title": "New Movie"
    },
    "relationships": {
      "directors": {
        "data": [
          {
            "id": "1",
            "type": "director-type-1"
          },
          {
            "id": "2",
            "type": "director-type-2"
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be deserialized to a <code>MovieWithTypedDirectors</code> where myType is "movies"
and 2 (empty) <code>DirectorWithType</code> objects.
The first <code>DirectorWithType</code> object with id = '1' and directorType = "director-type-1",
the second <code>DirectorWithType</code> object with id = '2' and directorType = "director-type-2",</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, only <code>List</code> and <code>Set</code> are supported collection classes.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="collection-model-deserialization"><a class="anchor" href="#collection-model-deserialization"></a>4.12. Deserialization of PagedModels</h3>
<div class="paragraph">
<p>While a server implementation of HTTP POST and PATCH takes single resources as input,
it is sometimes useful to be able to deserialize collection models and paged models. This is
helpful when a service consumes results from other services that produce JSON:API responses.</p>
</div>
<div class="paragraph">
<p>Here is an example of a serialized <code>PagedModel</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "Star Wars"
      },
      "links": {
        "imdb": "https://www.imdb.com/title/tt0076759/?ref_=ttls_li_tt"
      }
    },
    {
      "id": "2",
      "type": "movies",
      "attributes": {
        "title": "Avengers"
      },
      "links": {
        "imdb": "https://www.imdb.com/title/tt0848228/?ref_=fn_al_tt_1"
      }
    }
  ],
  "links": {
    "next": "http://localhost/movies?page[number]=2&amp;page[size]=2"
  },
  "meta": {
    "page": {
      "size": 2,
      "totalElements": 2,
      "totalPages": 2,
      "number": 1
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you deserialize the above JSON to a <code>PagedModel&lt;EntityModel&lt;Movie&gt;&gt;&gt;</code>: The page meta information will be deserialized, as well as the links in both movie entity models.
The same mechanism would work also for <code>CollectionModel&lt;EntityModel&lt;Movie&gt;&gt;&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="uuid"><a class="anchor" href="#uuid"></a>4.13. UUID Deserialization</h3>
<div class="paragraph">
<p>UUIDs (<code>java.util.UUID</code>) are supported natively for deserialization.
So a JSON like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "00000000-0001-e240-0000-00002f08ba38",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be correctly deserialized to an object of class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With
@JsonApiTypeForClass("movies")

</span><span class="fold-block">public class MovieWithUUID {

  private UUID id;
  private String title;
}
</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="polymorphy"><a class="anchor" href="#polymorphy"></a>4.14. Polymorphic Deserialization</h3>
<div class="paragraph">
<p>The easiest way for polymorphic deserialization is to use the JsonApiConfiguration to
assign a JSON:API type to a Java class and then also enable the mappings to be
used for deserialization, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">@Bean
JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
            .withTypeForClass(MovieSubclass.class, "my-movies")
            .withTypeForClassUsedForDeserialization(true));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then a POST to a controller method like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PostMapping("/movies")
public ResponseEntity&lt;?&gt; newMovie(@RequestBody EntityModel&lt;Movie&gt; movie) { ...
</code></pre>
</div>
</div>
<div class="paragraph">
<p>with JSON like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "data": {
    "type": "my-movies",
    "attributes": {
      "title": "Batman Begins"
    }
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be deserialized to a Java class of type <code>MovieSubclass</code>. Note that this mechanism overrides
the default deserialization to an object of the class given by the REST controller method&#8217;s signature.
The deserializer checks if the mapped Java type is assignable to the originally required Java type;
otherwise, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The same mechanism can also be used to deserialize polymorphic relationships.</p>
</div>
<div class="paragraph">
<p>Consider the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class MovieWithDirectors extends Movie {

  @JsonApiType String myType = "movies";

  @JsonIgnore
  @JsonApiRelationships("directors")
  List&lt;Director&gt; directors;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and a <code>JsonApiConfiguration</code> that looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Java" data-lang="Java">@Bean
JsonApiConfiguration jsonApiConfiguration() {
    return new JsonApiConfiguration()
        .withTypeForClass(DirectorWithEmail.class,  "directors-with-email")
        .withTypeForClassUsedForDeserialization(true));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then an HTTP POST to /movies with body</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "data": {
    "type": "movies",
    "attributes": {
      "title": "New Movie"
    },
    "relationships": {
      "directors": {
        "data": [
          {
            "id": "1",
            "type": "directors"
          },
          {
            "id": "2",
            "type": "directors-with-email"
          }
        ]
      }
    }
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>would create 2 directors in the <code>directors</code> list, both empty except for the <code>id</code> field.
But the first director would be an instance of class <code>Director</code>,
while the second director would be an instance of class <code>DirectorWithEmail</code>.</p>
</div>
<div class="sect3">
<h4 id="jackson-annotations"><a class="anchor" href="#jackson-annotations"></a>4.14.1. Jackson Annotations</h4>
<div class="paragraph">
<p>If the above mechanism does not fit your needs,
you can also configure polymorphic deserialization
on a per-class basis using Jackson annotations. The following example illustrates this:</p>
</div>
<div class="paragraph">
<p>Imagine a controller method like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PostMapping("/movies")
public ResponseEntity&lt;?&gt; newMovie(@RequestBody EntityModel&lt;Movie&gt; movie) { ...
</code></pre>
</div>
</div>
<div class="paragraph">
<p>and a subclass of <code>Movie</code> that contains a rating, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoArgsConstructor
@Data
@JsonApiTypeForClass("movies")
public class MovieWithRating extends Movie {
    private double rating;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could now annotate the <code>Movie</code> class with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)
@JsonSubTypes({
    @JsonSubTypes.Type(value = MovieWithRating.class, name = "movieWithRating")
})
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then an HTTP POST to /movies with body</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "data": {
    "type": "movies",
    "attributes": {
      "@type": "movieWithRating",
      "title": "Batman Begins",
      "rating": 8.2
    }
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be deserialized to an object of class <code>MovieWithRating</code>, even though the controller method accepts the superclass <code>Movie</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
@-Members were introduced in JSON:API version 1.1, see <a href="https://jsonapi.org/format/#document-member-names-at-members" class="bare">jsonapi.org/format/#document-member-names-at-members</a>.
From the JSON:API 1.1 spec:
&#8230;&#8203;an @-Member that occurs in an attributes object is not an attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Important: The above mechanism is also used for serialization, so you can set
the JSON:API <code>type</code> attribute (within data) to a more generic type while still serializing the
<code>@type</code> attribute to indicate the specialized type.
The JSON of the serialized Java object (of class <code>MovieWithRating</code>) would then look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "3",
    "type": "movies",
    "attributes": {
      "@type": "movieWithRating",
      "title": "Batman Begins",
      "rating": 8.2
    }
  },
  "links": {
    "self": "http://localhost/movies/3"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to use Jackson&#8217;s <code>@JsonSubTypes</code> annotation for polymorphic relationships.
Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoArgsConstructor
public class PolymorphicRelationEntity {

  @JsonApiId private String id;

  @JsonApiType private final String type = null;

  @JsonApiRelationships("superEntities")
  @JsonIgnore
  @Getter
  private final List&lt;SuperEntity&lt;?&gt;&gt; relation = null;
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonSubTypes({
  @JsonSubTypes.Type(value = SuperEChild.class, name = "superEChild"),
  @JsonSubTypes.Type(value = SuperEChild2.class, name = "superEChild2"),
})
public interface SuperEntity&lt;T&gt; {
  T getT();
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoArgsConstructor
public class SuperEChild&lt;T extends Collection&lt;?&gt;&gt; implements SuperEntity&lt;T&gt; {

  @JsonApiId private String id;

  @JsonApiType private final String type = null;

  @Override
  public T getT() {
    return null;
  }
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoArgsConstructor
public class SuperEChild2 implements SuperEntity&lt;String&gt; {

  @JsonApiId private String id;

  @JsonApiType private final String type = null;

  private final String extraAttribute = "";

  @Override
  public String getT() {
    return null;
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then a JSON like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "poly123",
    "type": "polymorphicRelationEntity",
    "relationships": {
      "superEntities": {
        "data": [
          {
            "id": "456",
            "type": "superEChild"
          },
          {
            "id": "789",
            "type": "superEChild2"
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be deserialized to a <code>PolymorphicRelationEntity</code> with 2 relationships,
the first one of Class <code>SuperEChild</code>, the second one of class <code>SuperEChild2</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, there is a restriction that the type attribute of both
<code>SuperEChild</code> and <code>SuperEChild2</code> must be <code>type</code>. For example, <code>_type</code> would not work.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error-handling"><a class="anchor" href="#error-handling"></a>4.15. Error Handling</h3>
<div class="paragraph">
<p>To create <code>JSON:API</code> compliant error messages, you can use <code>JsonApiErrors</code> and <code>JsonApiError</code></p>
</div>
<div class="paragraph">
<p>Here is an example of how to produce an error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">return ResponseEntity.badRequest()
    .body(
        JsonApiErrors.create()
            .withError(
                JsonApiError.create()
                    .withAboutLink("http://movie-db.com/problem")
                    .withTitle("Movie-based problem")
                    .withStatus(HttpStatus.BAD_REQUEST.toString())
                    .withDetail("This is a test case")));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result would be rendered as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "errors": [
    {
      "links": {
        "about": "http://movie-db.com/problem"
      },
      "status": "400 BAD_REQUEST",
      "title": "Movie-based problem",
      "detail": "This is a test case"
    }
  ]
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="more-generic-error-handling"><a class="anchor" href="#more-generic-error-handling"></a>4.15.1. More Generic Error Handling</h4>
<div class="paragraph">
<p>If you want to implement more generic error handling that converts exceptions
to JSON:API error responses, you can implement a <code>@ControllerAdvice</code> like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ControllerAdvice(annotations = RestController.class)
@Slf4j
public class ExceptionControllerAdvice {

  /** Handles all manually thrown exceptions of type JsonApiErrorsException. */
  @ExceptionHandler
  public ResponseEntity&lt;JsonApiErrors&gt; handle(JsonApiErrorsException ex) {
    log.error("JSON:API error: Http status:{}, message:{}", ex.getStatus(), ex.getMessage());
    return ResponseEntity.status(ex.getStatus()).body(ex.getErrors());
  }

  /**
   * Handles all exceptions which are not of type JsonAPIErrorsException and treats them as internal
   * errors or maps specific exceptions to specific HTTP status codes.
   */
  @ExceptionHandler
  public ResponseEntity&lt;JsonApiErrors&gt; handle(Exception ex) {
    log.error("Internal error: {}", ex.getMessage());
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
        .body(
            JsonApiErrors.create()
                .withError(CommonErrors.newInternalServerError().withDetail(ex.getMessage())));
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would then convert exceptions to JSON:API error responses like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "errors": [
        {
            "id": "58bab604-a149-452a-ab30-f61fafab80e7",
            "status": "500",
            "code": "xrn:err:platform:internalServerError",
            "title": "Internal server error",
            "detail": "JSON parse error: Illegal unquoted character ((CTRL-CHAR, code 13)): has to be escaped using backslash to be included in string value"
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, you can implement a <code>JsonApiErrorsException</code> like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Getter
public class JsonApiErrorsException extends RuntimeException {

  private final transient JsonApiErrors errors;
  private final HttpStatus status;

  public JsonApiErrorsException(JsonApiErrors errors, HttpStatus status) {
    super();
    this.errors = errors;
    this.status = status;
  }

  public JsonApiErrorsException(JsonApiError error) {
    super();
    this.errors = JsonApiErrors.create().withError(error);
    this.status = HttpStatus.valueOf(Integer.parseInt(error.getStatus()));
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>and provide <code>CommonErrors</code> like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CommonErrors {

  private CommonErrors() {}

  private static final JsonApiError resourceNotFound =
      JsonApiError.create()
          .withCode("xrn:err:platform:resourceNotFound")
          .withTitle("Resource Not Found")
          .withStatus("404");

  private static final JsonApiError badRequest =
      JsonApiError.create()
          .withCode("xrn:err:platform:badRequest")
          .withTitle("Bad Request")
          .withStatus("400");

  private static final JsonApiError internalServerError =
      JsonApiError.create()
          .withCode("xrn:err:platform:internalServerError")
          .withTitle("Internal server error")
          .withStatus("500");

  public static JsonApiError newResourceNotFound(String resourceType, String resourceId) {
    return resourceNotFound
        .withDetail(
            "Resource of type '" + resourceType + "' with id '" + resourceId + "' not found.")
        .withId(java.util.UUID.randomUUID().toString());
  }

  public static JsonApiError newBadRequestError(String message) {
    return badRequest.withId(java.util.UUID.randomUUID().toString()).withDetail(message);
  }

  public static JsonApiError newInternalServerError() {
    return internalServerError.withId(java.util.UUID.randomUUID().toString());
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can throw a <code>JsonApiErrorsException</code> like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.orElseThrow(
    () -&gt;
        new JsonApiErrorsException(
            CommonErrors.newResourceNotFound("movies", id.toString())));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>which would then be converted to a JSON:API error response.</p>
</div>
<div class="paragraph">
<p>You can find implementations of the <code>ExceptionControllerAdvice</code>, <code>JsonApiErrorsException</code>, and <code>CommonErrors</code> in the example code.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-side-support"><a class="anchor" href="#client-side-support"></a>5. Client-Side Support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="deserialization"><a class="anchor" href="#deserialization"></a>5.1. Deserialization</h3>
<div class="paragraph">
<p>Simple JSON:API-based JSON structures can be deserialized, but only the generic Spring HATEOAS representation
models are supported.</p>
</div>
<div class="paragraph">
<p>For example, a JSON structured like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "id": "1",
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  },
  "links": {
    "self": "http://localhost/movies/1"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be deserialized to an object of class <code>EntityModel&lt;Movie&gt;</code>,
where the <code>Movie</code> class looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">@Data
@NoArgsConstructor
@AllArgsConstructor
@With

</span><span class="fold-block">public class Movie {

  private String id;
  private String title;
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the deserialization mechanism is currently unable to deserialize all types of
complex JSON:API structures that can be built with the JSON:API model builder, but several features are already supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deserializing meta</p>
</li>
<li>
<p>Deserializing included resources into the relationship DTOs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, a JSON like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": [
    {
      "id": "1",
      "type": "movies",
      "attributes": {
        "title": "The Matrix"
      },
      "relationships": {
        "relatedMovies": {
          "data": {
            "id": "2",
            "type": "movies"
          }
        },
        "directors": {
          "data": [
            {
              "id": "1",
              "type": "directors"
            },
            {
              "id": "2",
              "type": "directors"
            }
          ]
        }
      }
    },
    {
      "id": "3",
      "type": "movies",
      "attributes": {
        "title": "Star Wars"
      },
      "relationships": {
        "directors": {
          "data": {
            "id": "3",
            "type": "directors"
          }
        }
      }
    }
  ],
  "included": [
    {
      "id": "1",
      "type": "directors",
      "attributes": {
        "name": "Lana Wachowski"
      }
    },
    {
      "id": "2",
      "type": "directors",
      "attributes": {
        "name": "Lilly Wachowski"
      }
    },
    {
      "id": "3",
      "type": "directors",
      "attributes": {
        "name": "George Lucas"
      }
    }
  ],
  "links": {
    "self": "http://localhost/movies",
    "first": "http://localhost/movies?page%5Bnumber%5D=0&amp;page%5Bsize%5D=10",
    "prev": "http://localhost/movies?page%5Bnumber%5D=0&amp;page%5Bsize%5D=10",
    "next": "http://localhost/movies?page%5Bnumber%5D=2&amp;page%5Bsize%5D=10",
    "last": "http://localhost/movies?page%5Bnumber%5D=9&amp;page%5Bsize%5D=10"
  },
  "meta": {
    "page": {
      "size": 10,
      "totalElements": 100,
      "totalPages": 10,
      "number": 1
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be deserialized into a <code>CollectionModel&lt;EntityModel&lt;MovieWithDirectors&gt;&gt;</code>, so that all the names
of the directors are set on the Java side.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>CollectionModel&lt;MovieWithDirectors&gt;</code> would NOT resolve the director names, because deserialization
of JSON:API-specific features like relationships only works with Spring HATEOAS representation models.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more examples of relationship deserialization, see the section <a href="#server-deserialization">Deserialization of JSON:API Types</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="rest-clients"><a class="anchor" href="#rest-clients"></a>5.2. REST Clients</h3>
<div class="paragraph">
<p>If you want to write a client that deserializes server responses into Java objects,
you can use Spring&#8217;s HTTP client APIs with JSON:API support.</p>
</div>
<div class="sect3">
<h4 id="restclient"><a class="anchor" href="#restclient"></a>5.2.1. RestClient (Spring Boot 4+)</h4>
<div class="paragraph">
<p>For Spring Boot 4 and later, use <code>RestClient</code> (which replaces <code>RestTemplate</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class JsonApiClientConfig {

    @Bean
    public RestClient jsonApiRestClient(JsonApiConfiguration jsonApiConfiguration) {
        JsonMapper jsonMapper = jsonApiConfiguration.getJsonMapper();

        // Register JSON:API module
        Jackson2JsonApiModule jackson2JsonApiModule =
            new Jackson2JsonApiModule(jsonApiConfiguration);
        jsonMapper.registerModule(jackson2JsonApiModule);

        return RestClient.builder()
            .baseUrl("http://localhost:8080")
            .defaultHeader("Accept", "application/vnd.api+json")
            .messageConverters(converters -&gt; {
                MappingJackson2HttpMessageConverter converter =
                    new MappingJackson2HttpMessageConverter();
                converter.setObjectMapper(jsonMapper);
                converter.setSupportedMediaTypes(
                    List.of(MediaType.parseMediaType("application/vnd.api+json"))
                );
                converters.add(0, converter);
            })
            .build();
    }
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resttemplate"><a class="anchor" href="#resttemplate"></a>5.2.2. RestTemplate (Legacy)</h4>
<div class="paragraph">
<p>For older Spring Boot versions, you can use RestTemplate with JSON:API configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableHypermediaSupport(type = {})
static class Config {

  public @Bean RestTemplate template() {
    return new RestTemplate();
  }

  @Bean
  public JsonApiMediaTypeConfiguration jsonApiMediaTypeConfiguration(
      ObjectProvider&lt;JsonApiConfiguration&gt; configuration,
      AutowireCapableBeanFactory beanFactory) {
    return new JsonApiMediaTypeConfiguration(configuration, beanFactory);
  }
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>RestTemplate</code> is in maintenance mode and will be removed in a future Spring Framework release.
For new applications using Spring Boot 4+, use <code>RestClient</code> instead.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="postWithNoId"><a class="anchor" href="#postWithNoId"></a>5.2.3. Creating POST requests without serialized JSON:API id</h4>
<div class="paragraph">
<p>If you want to use RestTemplate to make a POST request, the JSON:API id is often created by the server
and is not included in the JSON body. The easiest way to achieve this is to configure a marker value to indicate
that DTOs with this id value should not include the JSON:API id in the resulting JSON.</p>
</div>
<div class="paragraph">
<p>For example, if you specify a configuration like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">new JsonApiConfiguration().withJsonApiIdNotSerializedForValue("doNotSerialize"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>and create a Movie DTO with this id, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Movie movie = new Movie("doNotSerialize", "Star Wars");
</code></pre>
</div>
</div>
<div class="paragraph">
<p>the resulting JSON would look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "data": {
    "type": "movies",
    "attributes": {
      "title": "Star Wars"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="traverson"><a class="anchor" href="#traverson"></a>5.3. Traverson</h3>
<div class="paragraph">
<p>The hypermedia type <code>application/vnd.api+json</code> is currently not compatible with the <code>Traverson</code>
implementation provided by <a href="https://docs.spring.io/spring-hateoas/docs/3.0.0/reference/html/">Spring HATEOAS</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="link-discovery"><a class="anchor" href="#link-discovery"></a>5.4. Link Discovery</h3>
<div class="paragraph">
<p>When working with hypermedia-enabled representations, a common task is to find a link with a particular relation
type in it.
<a href="https://docs.spring.io/spring-hateoas/docs/3.0.0/reference/html/">Spring HATEOAS</a> provides JsonPath-based implementations of the <code>LinkDiscoverer</code> interface
for the configured hypermedia types.
When using this library, an instance supporting this hypermedia type (<code>application/vnd.api+json</code>)
is exposed as a Spring bean.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can set up and use an instance as follows
(where <code>source</code> is the exact JSON you saw in the <a href="#deserialization">Deserialization</a> section):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">LinkDiscoverer linkDiscoverer = new JsonApiLinkDiscoverer();
Links links = linkDiscoverer.findLinksWithRel(SELF, source);

assertThat(links.hasLink("self")).isTrue();
assertThat(links).map(Link::getHref).contains("http://localhost/movies/1");
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>6. Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several options for customizing the JSON:API rendering output.</p>
</div>
<div class="paragraph">
<p>For a specific JSON:API configuration, you can create a Spring bean of type JsonApiConfiguration.
Currently, you can configure:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Configuration</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Default</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JsonApiObject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set a JSON:API object with all <a href="https://jsonapi.org/format/#document-jsonapi-object">allowed properties</a>, such as version, ext, profile, and meta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PluralizedTypeRendered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether JSON:API types should be rendered as pluralized or non-pluralized class names.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pluralized</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LowerCasedTypeRendered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether JSON:API types should be rendered as lowercase or original class names.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lowercase</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PageMetaAutomaticallyCreated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether page information of a PagedModel should be rendered automatically as JSON:API meta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TypeForClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify if a specific Java class should be rendered with a specific JSON:API type. This is useful when representation model classes should use the JSON:API type of the domain model or when derived classes should use the JSON:API type of the superclass.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TypeForClassUsedForDeserialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the above "Java class to JSON:API type" mapping should also be used for deserialization. This is very useful for polymorphic use cases.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EmptyAttributesObjectSerialized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether empty attributes should be serialized as an empty JSON object, like <code>"attributes": {}</code>. If set to false, no "attributes" key is serialized when attributes are empty.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JsonApiIdNotSerializedForValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A marker value that indicates the JSON:API id should not be serialized. This is useful when creating JSON for a POST request. See also <a href="#postWithNoId">Creating POST requests without serialized JSON:API id</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not set</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MapperCustomizer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A lambda expression (<code>UnaryOperator&lt;JsonMapper.Builder&gt;</code>) to add additional configuration to the Jackson 3 <code>JsonMapper.Builder</code> used for serialization and deserialization. This allows customizing Jackson features, modules, or other settings. See <a href="#json-mapper-customization">JSON Mapper Customization</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">not set
<a id="links-configuration"></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JsonApiCompliantLinks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The following links are JSON:API compliant: <code>self</code>, <code>related</code>, <code>describedBy</code>, <code>next</code>, <code>prev</code>, <code>first</code>, and <code>last</code> for
<a href="https://jsonapi.org/format/#document-top-level">top-level links</a>. Only <code>self</code> is compliant for <a href="https://jsonapi.org/format/#document-resource-object-links">resource links</a>.
To allow any link, set this configuration to false.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JsonApi11LinkPropertiesRemovedFromLinkMeta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether Spring HATEOAS complex links should be serialized/deserialized in a backward-compatible (with version 1.x.x of this library) way. By default, the Spring HATEOAS properties title, type, and hreflang will be serialized only as top-level link
properties. These link properties were introduced in JSON:API 1.1,
see <a href="https://jsonapi.org/format/#auto-id&#8212;&#8203;link-objects" class="bare">jsonapi.org/format/#auto-id&#8212;&#8203;link-objects</a>. To serialize the Spring HATEOAS properties title, type, and hreflang both as top-level link properties and in the meta section, set this property to <code>false</code>. See also <a href="#links-configuration">[links-configuration]</a>.
Note that using the default setting, Spring HATEOAS complex links are rendered in a backward-incompatible way
(relative to version 1.x.x of this library which only supports JSON:API 1.0),
as clients might expect properties like title in the meta section.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LinksNotUrlEncoded</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set of link relations which are not URL encoded when serializing.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">empty set
<a id="links-placement-configuration"></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LinksAtResourceLevel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls where links are placed in JSON:API documents for single resource (EntityModel) serialization. When set to <code>true</code>, links are placed at the resource level (inside the resource object in the "data" section). When set to <code>false</code>, links are placed at the document level (top-level). See also <a href="#link-placement">Link Placement</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since the JSON:API recommendation uses square brackets in request parameter names,
those brackets are usually URL-encoded to %5B and %5D. If you want your server to also accept raw <code>[</code> and <code>]</code>
characters in the URL, add the following configuration to your Spring <code>application.properties</code>
when using Tomcat: <code>server.tomcat.relaxed-query-chars= [,]</code>. When this library automatically creates pagination links,
<code>[</code> and <code>]</code> characters are always URL-encoded.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of how you would implement a JSON:API configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JsonApiConfiguration jsonApiConfiguration() {
  return new JsonApiConfiguration()
      .withJsonApiObject(new JsonApiObject(true))
      .withPluralizedTypeRendered(false)
      .withLowerCasedTypeRendered(false)
      .withTypeForClass(MovieRepresentationModelWithoutJsonApiType.class, "my-movies")
      .withTypeForClassUsedForDeserialization(true)
      .withEmptyAttributesObjectSerialized(false)
      .withJsonApiIdNotSerializedForValue("-1")
      .withJsonApi11LinkPropertiesRemovedFromLinkMeta(false)
      .withJsonApiCompliantLinks(false);
}
</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="link-placement-configuration-example"><a class="anchor" href="#link-placement-configuration-example"></a>6.1. Link Placement Configuration Example</h3>
<div class="paragraph">
<p>To configure links to appear at the resource level instead of the document level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class JsonApiConfig {

    @Bean
    public JsonApiConfiguration jsonApiConfiguration() {
        return new JsonApiConfiguration()
            .withLinksAtResourceLevel(true);  <i class="conum" data-value="1"></i><b>(1)</b>
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Enable resource-level links for single resource (EntityModel) serialization</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When this configuration is enabled, links from EntityModel are placed inside the resource object
in the "data" section instead of at the document top level. See <a href="#link-placement">Link Placement</a> for more details
and examples.</p>
</div>
</div>
<div class="sect2">
<h3 id="json-mapper-customization"><a class="anchor" href="#json-mapper-customization"></a>6.2. JSON Mapper Customization</h3>
<div class="paragraph">
<p>Starting with version 3.0.0, this library uses <strong>Jackson 3</strong> (package <code>tools.jackson.<strong></code> instead of <code>com.fasterxml.jackson.</strong></code>).
You can customize the Jackson <code>JsonMapper</code> used for JSON:API serialization and deserialization through the
<code>mapperCustomizer</code> configuration option.</p>
</div>
<div class="paragraph">
<p>The customizer is a <code>UnaryOperator&lt;JsonMapper.Builder&gt;</code> that receives the Jackson <code>JsonMapper.Builder</code> and
returns a modified builder. This allows you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Enable or disable Jackson serialization/deserialization features</p>
</li>
<li>
<p>Register custom modules</p>
</li>
<li>
<p>Configure date/time formats</p>
</li>
<li>
<p>Add custom serializers or deserializers</p>
</li>
<li>
<p>Enable or disable pretty printing</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="example-basic-mapper-customization"><a class="anchor" href="#example-basic-mapper-customization"></a>6.2.1. Example: Basic Mapper Customization</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class JsonApiConfig {

    @Bean
    public JsonApiConfiguration jsonApiConfiguration() {
        return new JsonApiConfiguration()
            .withMapperCustomizer(builder -&gt;
                builder.enable(SerializationFeature.INDENT_OUTPUT)  <i class="conum" data-value="1"></i><b>(1)</b>
            );
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Enable pretty-printed JSON output</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="example-multiple-customizations"><a class="anchor" href="#example-multiple-customizations"></a>6.2.2. Example: Multiple Customizations</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class JsonApiConfig {

    @Bean
    public JsonApiConfiguration jsonApiConfiguration() {
        return new JsonApiConfiguration()
            .withMapperCustomizer(builder -&gt; builder
                .enable(SerializationFeature.INDENT_OUTPUT)  <i class="conum" data-value="1"></i><b>(1)</b>
                .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)  <i class="conum" data-value="2"></i><b>(2)</b>
                .enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)  <i class="conum" data-value="3"></i><b>(3)</b>
            );
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Enable pretty-printed JSON output</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Don&#8217;t fail when encountering unknown properties during deserialization</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Serialize dates as timestamps instead of ISO-8601 strings</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Jackson 3 Migration Notes:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>tools.jackson.databind.<strong></code> packages instead of <code>com.fasterxml.jackson.databind.</strong></code></p>
</li>
<li>
<p><code>JsonMapper</code> replaces <code>ObjectMapper</code> as the preferred API</p>
</li>
<li>
<p>Serializers and deserializers must use Jackson 3 base classes from <code>tools.jackson.*</code></p>
</li>
<li>
<p>Annotations remain in <code>com.fasterxml.jackson.annotation.*</code> (unchanged)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="accessing-the-configured-mapper"><a class="anchor" href="#accessing-the-configured-mapper"></a>Accessing the Configured Mapper</h5>
<div class="paragraph">
<p>You can obtain a fully configured <code>JsonMapper</code> instance from the configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JsonApiConfiguration config = new JsonApiConfiguration()
    .withMapperCustomizer(builder -&gt;
        builder.enable(SerializationFeature.INDENT_OUTPUT)
    );

JsonMapper mapper = config.getJsonMapper();  <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a <code>JsonMapper</code> with all customizations applied</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.0.1-SNAPSHOT<br>
Last updated 2025-12-24 14:40:25 UTC
</div>
</div>
</div>
  </div>
</div>
</body>
</html>